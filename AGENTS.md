# Правила для ИИ - Структура спринтов и задач

## 🎨 КРИТИЧЕСКИ ВАЖНО: ФОРМАТ ДОКУМЕНТОВ И ДИАГРАММЫ

**🚨 ВСЕ ДОКУМЕНТЫ ДОЛЖНЫ БЫТЬ В ФОРМАТЕ .QMD (QUARTO MARKDOWN)!**

- **НЕ ИСПОЛЬЗУЙ** `.md` файлы для документации проекта
- **ВСЕГДА ИСПОЛЬЗУЙ** `.qmd` файлы для лучшей поддержки диаграмм и схем
- **ОБЯЗАТЕЛЬНО** включай диаграммы и схемы во все документы для лучшего понимания
- **ИСКЛЮЧЕНИЕ**: Только чисто текстовые файлы (например, `.txt`, `.log`) могут не содержать диаграммы

### 📄 КОНВЕРТАЦИЯ ДОКУМЕНТОВ ЧЕРЕЗ MARKITDOWN MCP

**🚨 ОБЯЗАТЕЛЬНО**: Все файлы нестандартных форматов (PDF, DOCX, XLSX, PPTX, изображения и т.д.) **ОБЯЗАТЕЛЬНО** конвертируй через MarkItDown MCP в формат .qmd!

**Правила использования MarkItDown MCP:**

1. **Формат URI для локальных файлов**: `file:///local-directory/path/to/file`
   - ✅ ПРАВИЛЬНО: `file:///local-directory/info/sprint1/001_task-auth-system/requirements.pdf`
   - ❌ НЕПРАВИЛЬНО: `file://README.md` или `./docs/report.pdf`

2. **Формат URI для URL**: `https://example.com/file.pdf`
   - ✅ ПРАВИЛЬНО: `https://raw.githubusercontent.com/example/repo/main/doc.pdf`

3. **После конвертации**:
   - Сохраняй результат в .qmd файл
   - Обновляй индекс через Markdown Rules MCP (reindex_docs)
   - Добавляй ссылку на исходный файл в документации

**Пример использования:**

```javascript
// Конвертация PDF в Markdown
const markdown = await mcp_markitdown_convert_to_markdown({
  uri: "file:///local-directory/info/sprint1/001_task-auth-system/requirements.pdf"
})

// Сохранение в .qmd
write("info/sprint1/001_task-auth-system/requirements.qmd", markdown)
```

**Подробная документация**: См. раздел "MARKITDOWN MCP" в `.cursor/FILES_FLOW.md`

## СТРУКТУРА ПРОЕКТА

### Обязательная структура папок:
```
info/
├── sprints-status.qmd          # ОБЯЗАТЕЛЬНО: Общее состояние всех спринтов
│
├── sprint1/                    # Текущий спринт
│   ├── tasks-list.qmd          # ОБЯЗАТЕЛЬНО: Список всех задач спринта
│   ├── sprint-overview.qmd     # Обзор и план спринта
│   │
│   ├── 001_task-auth-system/   # Папка задачи (ОБЯЗАТЕЛЬНО с номером!)
│   │   ├── requirements.qmd    # ТЗ задачи (ОБЯЗАТЕЛЬНО со схемами!)
│   │   ├── current-stage.qmd   # Текущее состояние
│   │   ├── changelog.qmd       # История изменений
│   │   ├── test-cases.qmd      # ОБЯЗАТЕЛЬНО: Тест-кейсы
│   │   ├── api-schema.json     # Схемы, документы задачи
│   │   ├── mockups.png         # Макеты, схемы
│   │   └── notes.qmd           # Дополнительные заметки
│   │
│   ├── 002_task-user-profile/  # Другая задача спринта
│   │   ├── requirements.qmd
│   │   ├── current-stage.qmd
│   │   ├── changelog.qmd
│   │   ├── test-cases.qmd      # ОБЯЗАТЕЛЬНО
│   │   └── database-schema.sql
│   │
│   └── 003_task-notifications/ # Еще одна задача
│       ├── requirements.qmd
│       ├── current-stage.qmd
│       ├── changelog.qmd
│       └── test-cases.qmd      # ОБЯЗАТЕЛЬНО
│
├── sprint2/                    # Следующий спринт (завершенные задачи остаются)
│   ├── tasks-list.qmd
│   ├── sprint-overview.qmd
│   └── 004_task-payment-system/
│       ├── requirements.qmd
│       ├── current-stage.qmd
│       ├── changelog.qmd
│       └── test-cases.qmd
│
└── sprint3/                    # Будущие спринты
    └── ...
```

---

## НАЧАЛО РАБОТЫ

### 1. ОБЩИЙ СТАТУС ПРОЕКТА
**В корне info/ обязательно должен быть файл `sprints-status.qmd`**

### 2. ОПРЕДЕЛЕНИЕ СПРИНТА
**Всегда работаем в рамках текущего спринта!**

- Если нет папки спринта → создай `info/sprint[номер]/`
- Создай `tasks-list.qmd` - список всех задач спринта
- Создай `sprint-overview.qmd` с планом спринта
- Обнови `sprints-status.qmd` - добавь новый спринт
- Все новые задачи создаются только в текущем спринте

### 3. СОЗДАНИЕ ЗАДАЧИ
Для каждой новой задачи:

```bash
# Создаешь структуру:
info/sprint1/001_task-[название-задачи]/
├── requirements.qmd    # ОБЯЗАТЕЛЬНО (ОБЯЗАТЕЛЬНО со схемами!)
├── current-stage.qmd   # ОБЯЗАТЕЛЬНО  
├── changelog.qmd       # ОБЯЗАТЕЛЬНО
├── test-cases.qmd      # ОБЯЗАТЕЛЬНО (тест-кейсы)
└── [другие файлы]      # По необходимости
```

**Название задачи:** только английские буквы, цифры, дефисы. Пример: `001_task-auth-system`, `002_task-user-profile`

---

## ФАЙЛ ОБЩЕГО СТАТУСА ПРОЕКТА

### `sprints-status.qmd` - СОСТОЯНИЕ ВСЕХ СПРИНТОВ (В КОРНЕ INFO/)
```markdown
# Состояние проекта по спринтам

**Обновлено**: YYYY-MM-DD HH:MM
**Текущий активный спринт**: sprint3

---

## 🎯 АКТИВНЫЙ СПРИНТ

### Sprint 3 | В работе | 45%
**Период**: 2025-01-15 — 2025-01-29 (14 дней)
**Цель**: Внедрение системы платежей и уведомлений
**Задач**: 4 | **Завершено**: 1 | **В работе**: 2 | **Запланировано**: 1
**Критические задачи**: payment-integration
**Риски**: Задержка внешнего API для платежей

---

## 📋 ЗАВЕРШЕННЫЕ СПРИНТЫ

### Sprint 2 | Завершен | 100% ✅
**Период**: 2025-01-01 — 2025-01-14
**Цель**: Пользовательский профиль и базовая авторизация
**Результат**: Все задачи выполнены в срок
**Задач**: 3 | **Story Points**: 21/21
**Ключевые достижения**:
- Полная система авторизации (JWT, роли)  
- Редактирование профиля пользователя
- Интеграция с внешним хранилищем файлов

### Sprint 1 | Завершен | 90% ⚠️
**Период**: 2024-12-15 — 2024-12-31
**Цель**: Настройка проекта и базовой архитектуры
**Результат**: Частично выполнен, 1 задача перенесена
**Задач**: 4 | **Story Points**: 18/20
**Перенесенные задачи**: 
- task-monitoring-setup (сложность недооценена)

---

## 📊 ОБЩАЯ СТАТИСТИКА

| Метрика | Значение |
|---------|----------|
| Всего спринтов | 3 (1 завершен полностью, 1 частично, 1 активный) |
| Всего задач | 11 |
| Завершенных задач | 6 |
| Story Points выполнено | 39/61 |
| Средняя скорость | 19.5 SP за спринт |
| Процент успешности | 90% |

---

## 🎯 ПЛАНИРОВАНИЕ

### Sprint 4 | Запланирован
**Планируемый период**: 2025-01-30 — 2025-02-13
**Предполагаемая цель**: Аналитика и оптимизация производительности
**Приоритетные задачи**: 
- Интеграция с аналитическими системами
- Оптимизация запросов к БД
- Мониторинг и алерты

---

## ⚠️ ОБЩИЕ РИСКИ ПРОЕКТА
- Зависимость от внешних API может замедлять спринты
- Недооценка сложности интеграционных задач
- Необходимость дополнительного тестирования безопасности

## 🔄 ПРОЦЕССЫ И УЛУЧШЕНИЯ
- Ввести более детальную оценку задач в Story Points
- Добавить больше времени на тестирование интеграций
- Создать процедуру ранней оценки рисков внешних зависимостей
```

---

## ОБЯЗАТЕЛЬНЫЕ ФАЙЛЫ ЗАДАЧИ

### 1. `requirements.qmd` - ТЗ ЗАДАЧИ (ОБЯЗАТЕЛЬНО СО СХЕМАМИ!)
```markdown
# ТЗ: [Название задачи]

## Краткое описание
[1-2 предложения - суть задачи]

## Цель
[Конкретный результат, зачем нужно]

## Архитектурная схема
```{mermaid}
graph TD
    A[User] --> B[Frontend]
    B --> C[API Gateway]  
    C --> D[Auth Service]
    D --> E[Database]
    C --> F[User Service]
    F --> E
```

## Схема данных
```{mermaid}
erDiagram
    User {
        id uuid PK
        email string
        password_hash string
        role enum
        created_at timestamp
    }
    UserProfile {
        user_id uuid FK
        first_name string
        last_name string
        avatar_url string
    }
    User ||--|| UserProfile : has
```

## Функциональные требования
- ✅ Требование 1 (четко, измеримо)
- ✅ Требование 2
- ✅ Требование 3

## Технические требования  
- 🔧 JWT токены с временем жизни 24ч
- 🔧 Хеширование паролей bcrypt
- 🔧 Rate limiting: 5 попыток входа за 15 мин

## API схема (если применимо)
```yaml
POST /auth/login
Request:
  email: string (required)
  password: string (required, min 8 chars)
Response:  
  access_token: string
  refresh_token: string
  user: object
    id: uuid
    email: string
    role: string
```

## Критерии готовности
- [ ] Все API endpoints работают
- [ ] Покрытие тестами 80%+
- [ ] Документация API обновлена
- [ ] Security review пройден

## Ограничения и ограничения
- Не использовать сторонние OAuth на первом этапе
- Максимальное время ответа API: 200ms
- Поддержка только email авторизации

## Зависимости
- task-database-setup (должна быть готова)
- Настройка Redis для сессий

## Оценка сложности: [Простая/Средняя/Сложная/Критическая]
```

### 2. `current-stage.qmd` - ТЕКУЩЕЕ СОСТОЯНИЕ
```markdown
# Состояние: [Название задачи]

## Статус: [Создана/В работе/Тестирование/Заблокирована/Готова/Закрыта]
**Обновлено**: YYYY-MM-DD HH:MM
**Спринт**: sprint[номер]

## Прогресс по требованиям:
### Функциональные требования:
- [x] ✅ Требование 1 - выполнено
- [-] 🔄 Требование 2 - в работе (70%)
- [ ] ⏳ Требование 3 - не начато

### Технические требования:
- [x] ✅ Техтребование 1 - готово
- [-] 🔄 Техтребование 2 - в процессе

## Что делаю сейчас:
[Конкретная подзадача]

## Следующие шаги:
1. [Ближайший шаг]
2. [Следующий шаг]

## Блокеры:
[Что останавливает работу]

## Риски:
[Потенциальные проблемы]

## Готовность к закрытию: [0-100%]
```

### 3. `test-cases.qmd` - ТЕСТ-КЕЙСЫ (ОБЯЗАТЕЛЬНО)
```markdown
# Тест-кейсы: [Название задачи]

**Обновлено**: YYYY-MM-DD HH:MM

---

## 🧪 ПОЗИТИВНЫЕ СЦЕНАРИИ

### TC-001: Успешная авторизация с валидными данными
**Предусловия**: Пользователь зарегистрирован в системе
**Шаги**:
1. Открыть форму входа
2. Ввести корректный email: `user@example.com`
3. Ввести корректный пароль: `ValidPass123!`
4. Нажать "Войти"

**Ожидаемый результат**:
- Получен JWT токен
- Пользователь перенаправлен на главную страницу
- В header отображается имя пользователя
- Status code: 200

### TC-002: Обновление профиля пользователя
**Предусловия**: Пользователь авторизован
**Шаги**:
1. Перейти в настройки профиля
2. Изменить имя на "New Name"
3. Загрузить новый аватар (JPG, 2MB)
4. Сохранить изменения

**Ожидаемый результат**:
- Данные обновлены в БД
- Аватар загружен и отображается  
- Показано уведомление об успехе
- Status code: 200

---

## ❌ НЕГАТИВНЫЕ СЦЕНАРИИ

### TC-101: Авторизация с неверным паролем
**Предусловия**: Пользователь существует
**Шаги**:
1. Ввести корректный email: `user@example.com`
2. Ввести неверный пароль: `wrongpassword`
3. Нажать "Войти"

**Ожидаемый результат**:
- Показана ошибка "Неверный пароль"
- Токен не выдан
- Пользователь остается на форме входа
- Status code: 401

### TC-102: Попытка доступа без авторизации
**Предусловия**: Пользователь не авторизован
**Шаги**:
1. Прямой переход на `/profile`

**Ожидаемый результат**:
- Перенаправление на `/login`
- Показано сообщение "Необходимо войти"
- Status code: 302

### TC-103: Превышение лимита попыток входа
**Предусловия**: Аккаунт существует
**Шаги**:
1. 5 раз ввести неверный пароль подряд
2. Попытаться войти с правильным паролем

**Ожидаемый результат**:
- Аккаунт заблокирован на 15 минут
- Показана ошибка "Превышен лимит попыток"
- Status code: 429

---

## 🔒 ТЕСТЫ БЕЗОПАСНОСТИ

### TC-201: SQL injection в поле email  
**Шаги**: Ввести `' OR 1=1--` в поле email
**Ожидаемый результат**: Запрос заблокирован, ошибка валидации

### TC-202: XSS в поле имени профиля
**Шаги**: Ввести `<script>alert('xss')</script>` в имя
**Ожидаемый результат**: Скрипт экранирован, не выполняется

### TC-203: Попытка доступа к чужому профилю
**Шаги**: GET `/api/profile/other-user-id` без прав доступа  
**Ожидаемый результат**: Status code 403, Access denied

---

## ⚡ ТЕСТЫ ПРОИЗВОДИТЕЛЬНОСТИ

### TC-301: Нагрузочное тестирование авторизации
**Условия**: 100 одновременных запросов на `/auth/login`
**Ожидаемый результат**: 
- Время ответа < 200ms для 95% запросов
- 0% failed requests
- CPU usage < 80%

### TC-302: Тест загрузки больших файлов
**Условия**: Загрузка аватара 10MB
**Ожидаемый результат**: 
- Загрузка отклонена
- Показана ошибка "Максимальный размер: 5MB"

---

## 📱 ТЕСТЫ СОВМЕСТИМОСТИ

### TC-401: Работа в мобильных браузерах
**Устройства**: iPhone Safari, Android Chrome
**Проверки**:
- Форма авторизации адаптивна
- Все кнопки нажимаются
- Клавиатура не перекрывает поля

### TC-402: Работа в различных браузерах
**Браузеры**: Chrome 120+, Firefox 118+, Safari 17+
**Проверки**: Полная функциональность без ошибок

---

## 📊 КРИТЕРИИ ПРОХОЖДЕНИЯ ТЕСТОВ

| Тип тестов | Проходящих | Требуется |
|------------|------------|-----------|
| Позитивные | 100% | Все |
| Негативные | 100% | Все |
| Безопасность | 100% | Все |
| Производительность | 95% | Не менее 95% |
| Совместимость | 90% | Не менее 90% |

**Общий статус прохождения**: ❌ Не проведено / 🔄 В процессе / ✅ Пройдено
```
### 4. `changelog.qmd` - ИСТОРИЯ ИЗМЕНЕНИЙ
```markdown
# История: [Название задачи]

## 2025-01-15 14:30 - Создание задачи
- Создана папка задачи
- Написано ТЗ
- Задача добавлена в спринт 1

## 2025-01-15 15:45 - Начало разработки
- Начата работа над требованием 1
- Создан базовый модуль авторизации
- Добавлена схема API в api-schema.json

## 2025-01-15 17:20 - Прогресс
- Завершено требование 1
- Найден баг в логике валидации
- Исправлен баг, добавлены тесты

## 2025-01-16 09:15 - Блокер
- Заблокирована интеграция с БД
- Ожидаю схему БД от другой задачи
- Переключился на UI компоненты

## 2025-01-16 14:30 - Разблокирована
- Получена схема БД
- Завершена интеграция
- Все тесты проходят

## 2025-01-16 18:00 - Готова к закрытию
- Все требования выполнены
- Код ревью пройдено
- Задача готова к тестированию
```

---

## ДОПОЛНИТЕЛЬНЫЕ ФАЙЛЫ В ПАПКЕ ЗАДАЧИ

В папке задачи могут быть любые связанные документы:
- `api-schema.json` - схемы API
- `database-schema.sql` - схемы БД
- `mockups.png` - макеты интерфейса
- `architecture.qmd` - архитектурные решения (ОБЯЗАТЕЛЬНО со схемами!)
- `testing-plan.qmd` - план тестирования
- `deployment-notes.qmd` - заметки по деплою
- `research.qmd` - результаты исследований
- `meeting-notes.qmd` - заметки встреч
- любые другие файлы по задаче

---

## ФАЙЛ СПРИНТА

### 2. `sprint-overview.qmd` - ОБЗОР СПРИНТА
```markdown
# Спринт [номер]

## Информация о спринте
**Дата начала**: YYYY-MM-DD
**Дата окончания**: YYYY-MM-DD
**Цель спринта**: [Основная цель спринта]

## Задачи спринта:

### 🔄 В работе:
- **task-auth-system** (70%) - Система авторизации
- **task-user-profile** (30%) - Профиль пользователя

### ✅ Завершено:
- **task-setup-project** (100%) - Настройка проекта

### 📋 Запланировано:
- **task-payment-system** (0%) - Система платежей
- **task-notifications** (0%) - Уведомления

### ❌ Заблокировано:
- **task-analytics** - Ждем API от внешнего сервиса

## Прогресс спринта: [40%]

## Риски:
- [Описание рисков]

## Заметки:
[Важные решения, изменения в спринте]
```

---

## РАБОЧИЙ ПРОЦЕСС

### 1. НАЧАЛО НОВОЙ ЗАДАЧИ:
1. Обнови `sprints-status.qmd` - проверь текущий активный спринт
2. Определи текущий спринт (`info/sprint[номер]/`)
3. Обнови `tasks-list.qmd` - добавь новую задачу
4. Создай папку `001_task-[название]/` (ОБЯЗАТЕЛЬНО с номером!)
5. Создай 4 обязательных файла: requirements.qmd (ОБЯЗАТЕЛЬНО со схемами!), current-stage.qmd, changelog.qmd, test-cases.qmd
6. Заполни подробное ТЗ с mermaid схемами в `requirements.qmd`
7. Обнови `sprint-overview.qmd`

### 2a. ФОКУС НА ОДНОЙ ЗАДАЧЕ (ОБЯЗАТЕЛЬНО)
- Работай строго в рамках одной активной задачи, пока пользователь явно не разрешит её закрыть или переключиться на другую.
- До начала работ зафиксируй выбранную задачу в коммуникации (название и спринт) и обнови соответствующие файлы в её папке.
- Если возник блокер:
  - Опиши блокер в `current-stage.qmd` и в сообщении пользователю.
  - Предложи варианты обхода/следующие шаги.
  - Запроси явное разрешение на переключение задачи. Переключайся только после подтверждения.
- Не создавай параллельные задачи или документы вне папки текущей задачи без явного разрешения.
- Все вспомогательные изменения (скрипты, схемы, заметки) храни внутри папки текущей задачи или явно ссылайся на неё.
- Перед закрытием задачи запроси подтверждение у пользователя, затем выполни финальные действия: обнови `test-cases.qmd`, `changelog.qmd`, `current-stage.qmd`, `tasks-list.qmd`, `sprint-overview.qmd` и `sprints-status.qmd`.

### 2. ВО ВРЕМЯ РАБОТЫ:
- Постоянно обновляй `current-stage.qmd`
- Записывай все изменения в `changelog.qmd`
- Обновляй `test-cases.qmd` по мере реализации
- Добавляй документы в папку задачи по мере необходимости
- Обновляй прогресс в `tasks-list.qmd` (процент готовности)
- Обновляй общий прогресс в `sprint-overview.qmd`
- Обновляй `sprints-status.qmd` при значимых изменениях
- **ОБЯЗАТЕЛЬНО**: После любых изменений в frontend/backend проверяй:
  - **Линтер**: Используй `read_lints` для проверки ошибок линтера
  - **Типы**: Используй `make type-check` для проверки TypeScript
  - **Сборка**: Используй `make build-frontend` и `make build-backend` для проверки сборки
  - **Браузер**: Если приложение доступно через браузер (localhost или production URL), **ОБЯЗАТЕЛЬНО** проверяй через MCP browser tools:
    1. `browser_navigate` - перейди на URL приложения
    2. `browser_wait_for` - подожди загрузки (3-5 секунд)
    3. `browser_snapshot` - получи снимок страницы
    4. `browser_console_messages` - **КРИТИЧНО**: проверь консоль на ошибки (ERROR, ReferenceError, TypeError и т.д.)
    5. `browser_network_requests` - проверь сетевые запросы на 404/500 ошибки
    6. `browser_evaluate` - выполни тестовые проверки (например, проверка API endpoints)
  - **Makefile**: Используй `make check` для полной проверки перед коммитом

### 3. ЗАВЕРШЕНИЕ ЗАДАЧИ:
- Все критерии приемки выполнены
- Все тест-кейсы пройдены  
- Статус = "Готова" или "Закрыта"
- Финальная запись в changelog
- Обновлен статус в `tasks-list.qmd` (100%, ✅ завершено)
- Обновлены sprint-overview и sprints-status

### 4. НЕ АРХИВИРУЕМ:
- Завершенные задачи остаются в своих спринтах
- Спринты не удаляются, вся информация сохраняется
- В sprints-status.qmd помечаем спринты как "Завершен"

---

## КОММУНИКАЦИЯ

### Всегда сообщай:
1. **Спринт и задача**: "Спринт 1, задача auth-system:"
2. **Статус**: Текущее состояние задачи
3. **Прогресс**: % готовности по ТЗ
4. **Следующий шаг**: Что делаешь дальше
5. **Блокеры**: Что мешает, если есть

#### Правило фокуса
- Всегда запрашивай у пользователя явное разрешение прежде чем:
  - Переключиться на другую задачу
  - Закрыть текущую задачу
  - Создать новую задачу

### Пример:
> "Спринт 1, задача auth-system: завершил требование 1 (API авторизации), начинаю требование 2 (UI компоненты). Прогресс: 60%. Добавил схему API в папку задачи. Следующий шаг: создание формы логина."

---

## ПРОВЕРКА КАЧЕСТВА КОДА И БРАУЗЕРА

### Обязательная проверка перед коммитом

#### 1. Локальные проверки (Makefile)
```bash
# Полная проверка (lint + type-check + build)
make check

# Или по отдельности:
make lint              # Проверка линтера
make type-check        # Проверка типов TypeScript
make build-frontend    # Проверка сборки frontend
make build-backend     # Проверка сборки backend
```

#### 2. Проверка линтера (read_lints)
```typescript
// После любых изменений в коде
read_lints({ paths: ['frontend/src', 'backend/src'] })
```

#### 3. Проверка браузера через MCP (ОБЯЗАТЕЛЬНО для frontend)

**Последовательность проверки:**

1. **Навигация на страницу:**
   ```typescript
   browser_navigate({ url: 'https://azhukov-dev.ru/' }) // или localhost:8888
   ```

2. **Ожидание загрузки:**
   ```typescript
   browser_wait_for({ time: 5 }) // Ждем 5 секунд для полной загрузки
   ```

3. **Снимок страницы:**
   ```typescript
   browser_snapshot() // Получаем структуру страницы
   ```

4. **Проверка консоли (КРИТИЧНО!):**
   ```typescript
   browser_console_messages() // Получаем все сообщения консоли
   ```
   
   **Что проверять:**
   - ❌ `ReferenceError` - неопределенные переменные/функции
   - ❌ `TypeError` - ошибки типов
   - ❌ `SyntaxError` - синтаксические ошибки
   - ⚠️ `WARNING` - предупреждения (например, Tailwind CDN в production)
   - ❌ Любые другие `ERROR` сообщения

5. **Проверка сетевых запросов:**
   ```typescript
   browser_network_requests() // Получаем все сетевые запросы
   ```
   
   **Что проверять:**
   - ❌ Статус 404 - не найденные ресурсы
   - ❌ Статус 500 - ошибки сервера
   - ❌ Статус 403 - запрещенные запросы
   - ⚠️ Статус 429 - rate limiting

6. **Тестовые проверки (опционально):**
   ```typescript
   browser_evaluate({
     function: "() => fetch('/api/health').then(r => r.json())"
   }) // Проверка API endpoints
   ```

**Пример полной проверки:**
```typescript
// 1. Навигация
browser_navigate({ url: 'https://azhukov-dev.ru/' })

// 2. Ожидание
browser_wait_for({ time: 5 })

// 3. Снимок
browser_snapshot()

// 4. Проверка консоли (КРИТИЧНО!)
const consoleMessages = browser_console_messages()
// Анализируем на наличие ошибок

// 5. Проверка сети
const networkRequests = browser_network_requests()
// Анализируем на 404/500 ошибки

// 6. Тест API (если нужно)
browser_evaluate({
  function: "() => fetch('/api/health').then(r => r.json()).catch(e => ({ error: e.message }))"
})
```

#### 4. Критерии успешной проверки

**✅ Приложение готово к коммиту, если:**
- ✅ Линтер не выдает ошибок (`make lint`)
- ✅ TypeScript компилируется без ошибок (`make type-check`)
- ✅ Сборка проходит успешно (`make build-frontend`, `make build-backend`)
- ✅ В консоли браузера нет `ERROR` или `ReferenceError`
- ✅ Все сетевые запросы возвращают 200/201 (кроме ожидаемых 404 для несуществующих ресурсов)
- ✅ Страница загружается и отображается корректно

**❌ НЕ коммитить, если:**
- ❌ Есть ошибки линтера
- ❌ Есть ошибки TypeScript
- ❌ Сборка не проходит
- ❌ В консоли есть `ReferenceError`, `TypeError`, `SyntaxError`
- ❌ API endpoints возвращают 404/500
- ❌ Страница не загружается или отображается некорректно

---

## 🧠 MEMORY MCP - ПРАВИЛА ИСПОЛЬЗОВАНИЯ

### ⏰ КОГДА ИСПОЛЬЗОВАТЬ

**Использовать Memory MCP:**

1. **После принятия архитектурного решения** → сохранить обоснование
2. **После решения проблемы/бага** → сохранить проблему и решение
3. **После создания/изменения компонента** → создать/обновить entity и связи
4. **После завершения задачи** → обновить статус и результаты
5. **Перед началом новой задачи** → поиск контекста через `search_nodes()` или `open_nodes()`
6. **После изменения важных конфигураций** → обновить observations

**НЕ использовать:**
- Для промежуточных мыслей и вариантов
- Для временного контекста сессии
- Для дублирования документации
- Для секретов (токены, пароли)
- Для отладочной информации

### ✅ ЧТО ХРАНИТЬ

1. **Архитектурные решения** - почему выбран подход
2. **Правила проекта** - конвенции, стайлгайды
3. **Решенные проблемы** - проблема → решение → результат
4. **Важные конфигурации** - порты, лимиты, настройки
5. **Зависимости** - связи между задачами и компонентами

### ❌ ЧТО НЕ ХРАНИТЬ

1. Промежуточные мысли и варианты
2. Случайные обсуждения
3. Временный контекст сессии
4. Дублирование документации
5. Секреты и чувствительные данные
6. Отладочная информация

### 📋 ЧЕК-ЛИСТ ПЕРЕД ЗАПИСЬЮ

- [ ] Это окончательное решение?
- [ ] Это будет использоваться в будущем?
- [ ] Это уникальная информация?
- [ ] Это относится к проекту?
- [ ] Это не секрет?
- [ ] Это не временный контекст?

**Если хотя бы один ответ "нет" → НЕ сохранять!**

### 🔍 ПРАВИЛА ПОИСКА

- ✅ `search_nodes({ query: "конкретный вопрос" })` - семантический поиск
- ✅ `open_nodes({ names: ["сущность"] })` - получить конкретную сущность
- ❌ `read_graph()` - загружает всё, избегать

### 🏗️ СТРУКТУРИРОВАНИЕ

**Типы сущностей (entityType):**
- `Project`, `Component`, `Service`, `Task`, `Infrastructure`, `Technology`, `Rule`, `Configuration`

**Типы связей (relationType):**
- `part_of`, `uses`, `modifies`, `implements`, `powers`, `enhances`

**Оптимизация:**
- Избегай глубокой вложенности
- Группируй связанные observations
- Периодически проверяй на дубликаты
- Ограничивай размер файла (рекомендуется до 100KB)

### 🔄 WORKFLOW

**Перед началом задачи:**
```javascript
search_nodes({ query: "название задачи компонент" })
```

**После принятия решения:**
```javascript
add_observations([{
  entityName: "Component",
  contents: ["Окончательное решение: ..."]
}])
```

**После завершения задачи:**
```javascript
add_observations([{
  entityName: "Task",
  contents: ["Статус: Завершена", "Результат: ..."]
}])
```

### 🔧 ПОДДЕРЖАНИЕ КАЧЕСТВА

- **Периодическая проверка**: раз в месяц проверять актуальность записей
- **Очистка**: удалять устаревшие или неиспользуемые записи
- **Валидация**: проверять целостность файла после изменений
- **Резервные копии**: делать бэкапы перед крупными изменениями

### 📚 ДОПОЛНИТЕЛЬНАЯ ДОКУМЕНТАЦИЯ

- [Usage Guide](info/memory-mcp-usage.qmd) - краткая инструкция
- [Best Practices](info/memory-mcp-best-practices.qmd) - подробные правила

---

## 📚 CONTEXT7 MCP - ПРАВИЛА ИСПОЛЬЗОВАНИЯ

### ⏰ КОГДА ИСПОЛЬЗОВАТЬ

**Использовать Context7 MCP:**

1. **При создании задачи** → определять библиотеки и получать актуальную документацию
2. **При работе с новыми библиотеками** → получать примеры кода и API
3. **При ошибках API** → проверять актуальность методов и параметров
4. **При обновлении версий** → получать документацию для новой версии
5. **При написании requirements.qmd** → включать ссылки на актуальную документацию

**НЕ использовать:**
- Для библиотек, которых нет в Context7 (использовать Fetch MCP)
- Для простых вопросов, на которые можно ответить из памяти
- Для секретов и конфиденциальной информации

### ✅ ПРИОРИТЕТЫ ИСПОЛЬЗОВАНИЯ

**Высокий приоритет (⭐⭐⭐⭐⭐):** Express, React 19, Vite, React Hook Form, node-telegram-bot-api  
**Средний приоритет (⭐⭐⭐⭐):** better-sqlite3, TailwindCSS, React Three Fiber, Recharts  
**Низкий приоритет (⭐⭐⭐):** Framer Motion (лучше официальная документация)

### 🔧 КАК ИСПОЛЬЗОВАТЬ

#### 1. Определение библиотеки (resolve-library-id)

```javascript
const library = await mcp_context7_resolve-library-id({
  query: "Express web framework middleware",
  libraryName: "express"
})
// Выбрать вариант с наивысшим Benchmark Score и High Source Reputation
```

#### 2. Получение документации (query-docs)

```javascript
const docs = await mcp_context7_query-docs({
  libraryId: "/expressjs/express",
  query: "How to set up Express middleware for rate limiting"
})
```

**Правила формулировки запросов:**
- ✅ **Хорошо**: "How to set up Express middleware for rate limiting"
- ✅ **Хорошо**: "React 19 useEffect hook new features"
- ❌ **Плохо**: "Express" (слишком общий), "How to code" (неконкретный)

### 🔄 WORKFLOW

**При создании задачи:**
```javascript
// 1. Определить библиотеки
const lib = await mcp_context7_resolve-library-id({ query: "Express JWT", libraryName: "express" })
// 2. Получить документацию
const docs = await mcp_context7_query-docs({ libraryId: lib.id, query: "JWT authentication middleware" })
// 3. Включить в requirements.qmd через Task Orchestrator
```

**При разработке:**
```javascript
// Запрос документации → использование в коде → сохранение в Memory MCP
const docs = await mcp_context7_query-docs({ libraryId: "/expressjs/express", query: "rate limiting" })
// ... использование в коде ...
await mcp_memory_add_observations({ observations: [{ entityName: "Express Rate Limiting", contents: [docs.content] }] })
```

### 🎯 ИНТЕГРАЦИЯ С ДРУГИМИ MCP

- **Task Orchestrator**: автоматически определять библиотеки при создании задачи, включать документацию в секции
- **Memory MCP**: сохранять версии библиотек из Context7, использовать для поиска контекста
- **Markdown Rules MCP**: автоматически включать ссылки на актуальную документацию

### ⚠️ FALLBACK СТРАТЕГИЯ

Если Context7 недоступен → использовать Fetch MCP для получения официальной документации → сохранить в Memory MCP

### 📊 МЕТРИКИ

- Время ответа: `resolve-library-id` < 1 сек, `query-docs` 1-3 сек
- Успешность: > 95%, Релевантность: 90-100%

### 📚 ДОПОЛНИТЕЛЬНАЯ ДОКУМЕНТАЦИЯ

- [Анализ Context7 MCP](info/context7-mcp-analysis.qmd) - полный анализ
- [Отчет о тестировании](info/context7-mcp-testing-report.qmd) - результаты тестирования

---

## 🌐 BROWSER MCP (CURSOR BROWSER EXTENSION) - ПРАВИЛА ИСПОЛЬЗОВАНИЯ

### ⏰ КОГДА ИСПОЛЬЗОВАТЬ

**Использовать Browser MCP:**

1. **ОБЯЗАТЕЛЬНО после изменений в frontend** → автоматическая проверка консоли и сетевых запросов
2. **Перед коммитом frontend кода** → проверка на ошибки в браузере
3. **При работе с frontend задачами** → визуальная проверка реализации
4. **При отладке проблем** → проверка консоли и сетевых запросов
5. **При тестировании API endpoints** → проверка через `browser_evaluate`
6. **При проверке адаптивности** → изменение размера окна и проверка

**НЕ использовать:**
- Для backend-only задач (без frontend компонентов)
- Для задач, не связанных с веб-интерфейсом

### 🔧 КАК ИСПОЛЬЗОВАТЬ

#### Базовый workflow проверки

```javascript
// 1. Навигация на страницу
await mcp_cursor-browser-extension_browser_navigate({ url: 'https://azhukov-dev.ru/' })

// 2. Ожидание загрузки
await mcp_cursor-browser-extension_browser_wait_for({ time: 5 })

// 3. Снимок страницы (для анализа структуры)
const snapshot = await mcp_cursor-browser-extension_browser_snapshot()

// 4. Проверка консоли (КРИТИЧНО!)
const consoleMessages = await mcp_cursor-browser-extension_browser_console_messages()
// Анализ: ReferenceError, TypeError, SyntaxError, ERROR

// 5. Проверка сетевых запросов
const networkRequests = await mcp_cursor-browser-extension_browser_network_requests()
// Анализ: 404, 500, 403 ошибки

// 6. Тест API (опционально)
await mcp_cursor-browser-extension_browser_evaluate({
  function: "() => fetch('/api/health').then(r => r.json())"
})
```

#### Автоматический фикс проблем

**Если найдены ошибки в консоли:**
```javascript
// 1. Анализ ошибок
const errors = consoleMessages.filter(msg => 
  msg.type === 'error' || 
  msg.text.includes('ReferenceError') || 
  msg.text.includes('TypeError')
)

// 2. Если есть ошибки → исправить код
// 3. Повторить проверку
```

**Если найдены ошибки в сети:**
```javascript
// 1. Анализ сетевых ошибок
const failedRequests = networkRequests.filter(req => 
  req.status >= 400 && req.status !== 404 // 404 может быть ожидаемым
)

// 2. Если есть ошибки → исправить backend/API
// 3. Повторить проверку
```

### ✅ КРИТЕРИИ УСПЕШНОЙ ПРОВЕРКИ

**✅ Приложение готово, если:**
- ✅ В консоли нет `ERROR`, `ReferenceError`, `TypeError`, `SyntaxError`
- ✅ Все сетевые запросы возвращают 200/201 (кроме ожидаемых 404)
- ✅ Страница загружается и отображается корректно
- ✅ API endpoints работают (если проверялись)

**❌ НЕ коммитить, если:**
- ❌ Есть ошибки в консоли браузера
- ❌ API endpoints возвращают 404/500
- ❌ Страница не загружается или отображается некорректно

### 🔄 ИНТЕГРАЦИЯ В WORKFLOW

**После изменений в frontend:**
1. Запустить проверку через Browser MCP
2. Если найдены ошибки → исправить
3. Повторить проверку до успешного результата
4. Обновить `current-stage.qmd` с результатами проверки

**Перед коммитом:**
1. **ОБЯЗАТЕЛЬНО** выполнить полную проверку браузера
2. Задокументировать результаты в changelog
3. Только после успешной проверки → коммит

### 📚 ДОПОЛНИТЕЛЬНАЯ ДОКУМЕНТАЦИЯ

- См. раздел "ПРОВЕРКА КАЧЕСТВА КОДА И БРАУЗЕРА" выше для детальной последовательности

---

## ГЛАВНЫЕ ПРИНЦИПЫ:

✅ **Все задачи только в рамках спринтов**
✅ **Каждая задача = отдельная папка с номером NNN_**  
✅ **4 обязательных файла в каждой задаче (.qmd)**
✅ **tasks-list.qmd ВСЕГДА актуальный с процентами готовности**
✅ **Все документы задачи в её папке**
✅ **Постоянно обновляй состояние и историю**
✅ **Веди обзор спринта**
✅ **ВСЕ документы в формате .qmd с диаграммами и схемами**

✅ **Фокус на одной задаче до явного разрешения пользователя закрыть/переключиться**

❌ **НЕ создавай задачи вне спринтов**
❌ **НЕ забывай обновлять tasks-list.qmd при любых изменениях**
❌ **НЕ разбрасывай документы по разным местам**
❌ **НЕ забывай обновлять файлы состояния**
❌ **НЕ создавай документы без диаграмм и схем**